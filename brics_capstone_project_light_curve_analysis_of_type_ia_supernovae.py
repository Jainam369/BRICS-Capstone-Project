# -*- coding: utf-8 -*-
"""BRICS Capstone Project - Light Curve Analysis of Type-Ia Supernovae.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Eu-RKBrSVb572tOBfPO3fCVqMjOHGIv9

Light Curve Analysis of Type-Ia Supernovae
 ---

  Objective:

*   To Plot Flux vs Time for different Supernova
*   Fitting the light curve with SALT-2 extended model to obtain the parameters, such as x_0(peak magnitude), x_1(Stretch), t_0(peak time), c(color)
*   Try to compare the observed distance modulus from the obtained parameters with the lcdm model.

Type-Ia Supernova
---

Type-Ia Supernovae are among the most energetic explosions in the universe. They occur in binary systems where a white dwarf accretes matter from its companion. Upon approaching the Chandrasekhar limit (~1.4 solar masses), the balance between gravity and electron degeneracy pressure collapses, triggering a thermonuclear runaway that completely disrupts the white dwarf. This Object's acts as a standardize candle, means consistent peak mangnitude. Therefore used to inferred distances using their luminosities.



Data Description
---
Here in the analysis we took the photometric data of around 195 low-z type-Ia Supernova from Dark Energy Survey(DES) 3YR data set. The data column we are interested in the analysis are the 'MJD'(observation time), 'FLUXCAL'(Magnitude), 'FLUXCALERR'(Corresponding error), and redshift at which it located. Also we have the information of the filters, used here are the g(green), r(red), i(infrared), z(more red, towards longer wavelength).


Data Drive Link
---
https://drive.google.com/drive/folders/1A1NCb32kGmL7NKrgM_lfc9k4OzX8EGGh?usp=sharing
"""

!pip install sncosmo          # required for light-curve analysis, specifically for handling supernovae
!pip install iminuit

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
from astropy.table import Table
import sncosmo
import matplotlib.pyplot as plt
import re # re stands for regular expression a module in python, provide function to search, match using patterns. That allows pattern matching and text extraction from strings.

# Here in this cell, first we seperate out all the redshift correspond to respective supernova. Because later in the analysis for model fitting, the model needs a redshift as an input.
# We have to also take care of accessing the data, which starts from after 'VARLIST' (can see below).
# We have to also rename the column('MJD', 'BAND', 'FLUXCAL', 'FLUXCALERR') according to the sncosmo readable, and for the 'BAND' as we are using DES data have to rename band name also.
# Two other coulumn required for analysis, are the 'zp'(zero-point) and 'zpsys'(zero-point system)

#--- Example for showcasing the strucutre of .dat file---
pd.set_option('display.max_rows', None)
DF = pd.read_csv('/content/drive/MyDrive/DES-SN 3YR/des_01346387.dat')





def read_sn_file(filepath):
    with open(filepath, 'r') as f:
        lines = f.readlines()

    # --- Extract redshift ---
    redshift_line = [line for line in lines if "REDSHIFT_FINAL" in line][0]
    redshift = float(re.search(r'REDSHIFT_FINAL:\s+([0-9.]+)', redshift_line).group(1))

    # --- Find where observation data starts ---
    data_start_index = next(i for i, line in enumerate(lines) if line.startswith('VARLIST'))

    # Get column names (after 'VARLIST:')
    colnames = lines[data_start_index].split(':')[1].split()


    # Extract the observation lines
    obs_lines = lines[data_start_index + 1:]
    obs_lines = [line.split('OBS: ')[1] for line in obs_lines if line.startswith('OBS:')]

    # Convert to DataFrame
    df = pd.DataFrame([line.split() for line in obs_lines], columns=colnames)

    # --- Select and rename relevant columns for sncosmo ---
    df = df[['MJD', 'BAND', 'FLUXCAL', 'FLUXCALERR']]
    df.columns = ['time', 'band', 'flux', 'fluxerr']

    # ✅ Map bands to DES filter names
    band_map = {'g': 'desg', 'r': 'desr', 'i': 'desi', 'z': 'desz'}
    df['band'] = df['band'].map(band_map)

    # --- Convert data types explicitly ---
    df['time'] = df['time'].astype(float)
    df['flux'] = df['flux'].astype(float)
    df['fluxerr'] = df['fluxerr'].astype(float)

    # Add zp and zpsys
    df['zp'] = 27.5 # reference magnitude

    df['zpsys'] = 'ab' # magnitude system, required because, the model uses the energy units for flux but in astronomy the telescope and better representation 'magnitude' system is preferred.

    return Table.from_pandas(df), redshift

print(DF)
pd.DataFrame(DF)

# In this cell we define function to evaluate the fitness of the model to the observed data within 2 sigma.


def evaluate_model_fitness(data_table, model):
    """
    Returns the fraction of data points where the model prediction is within 2σ of the observed flux.
    """
    times = data_table['time']
    bands = data_table['band']
    flux_obs = data_table['flux']
    flux_err = data_table['fluxerr']



    count_within_2sigma = 0
    total = len(data_table)

    for t, b, f_obs, ferr in zip(times, bands, flux_obs, flux_err):
        try:
            f_model = model.bandflux(b, t, zp=27.5, zpsys='ab')
            if abs(f_model - f_obs) <= 2 * ferr:
                count_within_2sigma += 1
        except Exception:
            pass  # Skip problematic points

    return count_within_2sigma / total if total > 0 else 0

# In this cell we are doing model fitting with 'salt2-extended' model. The model returns the following parameters 't0', 'x0', 'x1', 'c'
# t0 : time of the peak magnitude, x0 : interpret the apparent peak magnitude, x1 : tells the stretch of the curve, c : color, gives information about dust interferring

def fit_sn(filepath):
    data_table, redshift = read_sn_file(filepath)

    model = sncosmo.Model(source='salt2-extended')
    model.set(z=redshift)

    result, fitted_model= sncosmo.fit_lc(data_table, model,
                                          ['t0', 'x0', 'x1', 'c'],
                                         bounds={'t0': (data_table['time'].min() - 10, data_table['time'].max() + 10), 'x1': (-3,3), 'c':(-0.3,0.3)})


      # Evaluate fitness within 2σ
    fitness_2sigma = evaluate_model_fitness(data_table, fitted_model)
    print(f"Fitness within 2σ: {fitness_2sigma:.2%}")
    # Optional Plot
    sncosmo.plot_lc(data_table, model=fitted_model,errors=result.errors)
    plt.title(filepath.split('/')[-1])
    plt.show()

    return result, redshift, fitness_2sigma

# This cell gives you the table of data and only light-curve plot for each supernoave.
import os
# === Directory with SN .dat files ===
data_dir = '/content/drive/MyDrive/DES-SN 3YR'

# === Loop over each SN file ===
for file in os.listdir(data_dir):
    if file.endswith('.dat'):
        full_path = os.path.join(data_dir, file)

        try:
            # Read photometric data
            data_table, redshift = read_sn_file(full_path)
            df = data_table.to_pandas()

            print(f"\n===== {file} =====")
            print(f"Redshift: {redshift}")
            print(df)

            # === Plot light curve ===
            plt.figure(figsize=(8, 6))
            for band in df['band'].unique():
                band_data = df[df['band'] == band]
                plt.errorbar(band_data['time'], band_data['flux'],
                             yerr=band_data['fluxerr'],
                             fmt='o', label=band)

            plt.title(f'Light Curve: {file} (z={redshift:.3f})')
            plt.xlabel('MJD (Time)')
            plt.ylabel('Flux')
            plt.legend()
            plt.grid(True)
            plt.tight_layout()
            plt.show()

        except Exception as e:
            print(f"Failed to process {file}: {e}")

data_dir = '/content/drive/MyDrive/DES-SN 3YR'
results = []

for file in os.listdir(data_dir):
    if file.endswith('.dat'):
        full_path = os.path.join(data_dir, file)
        print(f"Processing: {file}")
        try:
            result, z, fitness_2sigma = fit_sn(full_path)



            results.append({
                'filename': file,
                'z': z,
                't0': result.parameters[1],
                'x0': result.parameters[2],
                'x1': result.parameters[3],
                'c': result.parameters[4],
                'chi2': result.chisq,
                'ndof': result.ndof,
                'errors': result.errors,
                'fitness_2sigma': fitness_2sigma


            })
        except Exception as e:
            print(f"Failed to process {file}: {e}")

"""# Plot's Explanation
 * Supernova emits light across the spectrum ranging from UV to infra-red. Therefore to capture the nature we used multi-filters, like griz---green-blue(400-500 nm), red(500-700 nm), infrared(700-850 nm), and depper infrared(850-1000nm).

 * The 'g' band fade faster since it has hotter emission
 * The other ones stays brighter longer due to cooler emission mostly due to foreground dust or in our own milkyway galaxy.
 * Analysing in all filter's helps to understand temperature evolution, energy output, distance inference and indeed the supernova physics.

 * The SALT-2 EXTENDED model has the algorithm to fit the data points most accurately by varying the parameters(x0,t0,x1,c).
"""

# Saved the parameter information in a csv file
df_results = pd.DataFrame(results)
df_results.to_csv('sncosmo_multifit_results.csv', index=False)

"""Distance Modulus:

* Distance Modulus is a quantity used to measure the distance of distant objects
having known the absolute and apparent magnitude of that object.


 * Observationally one can determine using Tripp's formula:
           μ_obs = m - M + α*x1 - β*c + Δ_bias
 *   m = -2.5log(x0)       
 *   Now, we have the information of x0,x1, and c from fitting using that we inferred the observed distance modulus
"""

df = pd.read_csv("/content/sncosmo_multifit_results.csv")

# Constants
alpha = 0.14   # Stretch coefficient
beta = 3.1     # Color coefficient
M = -19.36  # Absolute magnitude of SNe Ia

# Compute m_B and distance modulus
df['mB'] = -2.5 * np.log10(df['x0'])  # Apparent peak magnitude
df['mu'] = df['mB'] - M + alpha * df['x1'] - beta * df['c']

df['mu'].mean()

df['fitness_2sigma'].mean()

# Plot

plt.figure(figsize=(8,6))
plt.scatter(np.log10(df['z']), df['mu'], c='green', s=25, label='Supernovae')
plt.xlabel(r'$\log_{10}(z)$')
plt.ylabel(r'Distance Modulus $\mu$')
plt.title("Hubble Diagram from SN Light Curves")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Comparing distance modulus from observatios and model prediction.


from astropy.cosmology import FlatLambdaCDM

cosmo = FlatLambdaCDM(H0=70, Om0=0.3)
z_vals = df['z']
mu_model = cosmo.distmod(z_vals).value   # built-in function distance modulus

plt.figure(figsize=(8,6))
plt.scatter(np.log10(df['z']), df['mu'], label='Observed SN', color='green', s=20)



plt.plot(np.log10(z_vals), mu_model, label='ΛCDM Model', color='red')
plt.xlabel(r'$\log_{10}(z)$')
plt.ylabel(r'Distance Modulus $\mu$')
plt.legend()
plt.title("Hubble Diagram with ΛCDM Comparison")
plt.grid(True)
plt.tight_layout()
plt.show()

"""Chi-Squared:
---
It is statistical parameter to inferred the wellness of model fit to the observed data,

χ^2 = ∑ (OBSERVED - MODEL VALUE)/ UNCERTANITY IN OBSERVED VALUE


 Here in our case context is FLUX of the Supernovae

"""

# Calculate reduced chi-squared for each SN
df['chi2_reduced'] = df['chi2'] / df['ndof'] # ndof is number of degree of freedom = (no. of datapoints - no. of free parameters) , we have 4 free parameters(x0,x1,t0,c)
df['chi2_reduced'].mean()

# Plot histogram of reduced chi-squared
plt.figure(figsize=(8, 6))
plt.hist(df['chi2_reduced'], bins=50, color='skyblue', edgecolor='black')
plt.title('Distribution of Reduced Chi-Squared ($\chi^2_{reduced}$)', fontsize=14)
plt.xlabel('$\chi^2_{reduced}$', fontsize=12)
plt.ylabel('Number of Supernovae', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""

Result and Interpretation:
---

We obtained the light curve plots and the parameters, x0,x1,t0,c by fitting salt2-extended model.
* x0: Shows the amplitude, and can convert into 'm'
apparent magnitude.
* x1: Describes time stretching of the light curve, more means broader---brighter SN.
* t0: peak time corresponding to peak brightness.
* c:  reflects the color excess, positive--redder, negative---bluer.

All this parameter gives you the information on nature of SNe and eventually also tells you the distance. Followed by this we compute distance modulus, although it matched the hubble diagram---distant object's are more farther and less appeared luminous, means universe is expanding. There is a offset with the lcdm model and the reason one can deduce was due to complexcity that's why not considering the bias factor in distance modulus. Which required further an simulation processes.

We have also compute the fitness of the model with the data within 2 sigma and got an average 93% . We plotted histogram for the reduced chi-square and the average value produce to ≈ 1.97. Which is moderately good, usually it has to be around ≈1. But here as we mentioned, we didn't take any bias factor.


Conclusion and Future Work:
---

Here, we consider the DES-3YR dataset of 195 type-Ia Supernovae of low-redshift. The aim was to extract the parameters from light-curve analysis and came out to be moderately good from the SALT-2 extended model. The comparing plot of distance modulus from lcdm model and observation has the vertical offset, one thing was clear that indeed it follow the trend. In the analysis we didn't consider any biases for parameters, one of the reason was neglecting the biases for parameters. In future one can update on this file for better accuracy and further explorarion and insights like,



* Working on bias to improve the accuracy.
* More data or different dataset for Supernovae.
* Cosmological parameter estimation, H_0, Ω_m, Ω_DE. And beyond ΛCDM we can use different model for analysis.
* Another important work is to implement the ML and neural networks.



References:
---

https://des.ncsa.illinois.edu/releases/sn"""